{"version":3,"file":"common.js","sourceRoot":"","sources":["../../../src/compositemark/common.ts"],"names":[],"mappings":"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","sourcesContent":["import {isBoolean, isString} from 'vega-util';\nimport {CompositeMark, CompositeMarkDef} from '.';\nimport {Channel} from '../channel';\nimport {Encoding, reduce} from '../encoding';\nimport {Field, FieldDef, FieldDefWithoutScale, isContinuous, isFieldDef, PositionFieldDef} from '../fielddef';\nimport * as log from '../log';\nimport {ColorMixins, GenericMarkDef, isMarkDef, Mark, MarkConfig, MarkDef} from '../mark';\nimport {GenericUnitSpec, NormalizedUnitSpec} from '../spec';\nimport {Orient} from '../vega.schema';\n\nexport type PartsMixins<P extends string> = Partial<Record<P, boolean | MarkConfig>>;\n\nexport type GenericCompositeMarkDef<T> = GenericMarkDef<T> &\n  ColorMixins & {\n    /**\n     * The opacity (value between [0,1]) of the mark.\n     */\n    opacity?: number;\n\n    /**\n     * Whether a composite mark be clipped to the enclosing groupâ€™s width and height.\n     */\n    clip?: boolean;\n  };\n\nexport function makeCompositeAggregatePartFactory<P extends PartsMixins<any>>(\n  compositeMarkDef: GenericCompositeMarkDef<any> & P,\n  continuousAxis: 'x' | 'y',\n  continuousAxisChannelDef: PositionFieldDef<string>,\n  sharedEncoding: Encoding<string>,\n  compositeMarkConfig: P\n) {\n  const {scale, axis} = continuousAxisChannelDef;\n\n  return (\n    partName: keyof P,\n    mark: Mark | MarkDef,\n    positionPrefix: string,\n    endPositionPrefix: string = undefined,\n    extraEncoding: Encoding<string> = {}\n  ) => {\n    const title =\n      axis && axis.title !== undefined\n        ? undefined\n        : continuousAxisChannelDef.title !== undefined\n        ? continuousAxisChannelDef.title\n        : continuousAxisChannelDef.field;\n\n    return partLayerMixins<P>(compositeMarkDef, partName, compositeMarkConfig, {\n      mark, // TODO better remove this method and just have mark as a parameter of the method\n      encoding: {\n        [continuousAxis]: {\n          field: positionPrefix + '_' + continuousAxisChannelDef.field,\n          type: continuousAxisChannelDef.type,\n          ...(title ? {title} : {}),\n          ...(scale ? {scale} : {}),\n          ...(axis ? {axis} : {})\n        },\n        ...(isString(endPositionPrefix)\n          ? {\n              [continuousAxis + '2']: {\n                field: endPositionPrefix + '_' + continuousAxisChannelDef.field,\n                type: continuousAxisChannelDef.type\n              }\n            }\n          : {}),\n        ...sharedEncoding,\n        ...extraEncoding\n      }\n    });\n  };\n}\n\nexport function partLayerMixins<P extends PartsMixins<any>>(\n  markDef: GenericCompositeMarkDef<any> & P,\n  part: keyof P,\n  compositeMarkConfig: P,\n  partBaseSpec: NormalizedUnitSpec\n): NormalizedUnitSpec[] {\n  const {clip, color, opacity} = markDef;\n\n  const mark = markDef.type;\n\n  if (markDef[part] || (markDef[part] === undefined && compositeMarkConfig[part])) {\n    return [\n      {\n        ...partBaseSpec,\n        mark: {\n          ...(compositeMarkConfig[part] as MarkConfig),\n          ...(clip ? {clip} : {}),\n          ...(color ? {color} : {}),\n          ...(opacity ? {opacity} : {}),\n          ...(isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : {type: partBaseSpec.mark}),\n          style: `${mark}-${part}`,\n          ...(isBoolean(markDef[part]) ? {} : (markDef[part] as MarkConfig))\n        }\n      }\n    ];\n  }\n  return [];\n}\n\nexport function compositeMarkContinuousAxis<M extends CompositeMark>(\n  spec: GenericUnitSpec<Encoding<string>, CompositeMark | CompositeMarkDef>,\n  orient: Orient,\n  compositeMark: M\n): {\n  continuousAxisChannelDef: PositionFieldDef<string>;\n  continuousAxisChannelDef2: FieldDef<string>;\n  continuousAxisChannelDefError: FieldDef<string>;\n  continuousAxisChannelDefError2: FieldDef<string>;\n  continuousAxis: 'x' | 'y';\n} {\n  const {encoding} = spec;\n\n  let continuousAxisChannelDef: PositionFieldDef<string>;\n  let continuousAxisChannelDef2: FieldDefWithoutScale<string>;\n  let continuousAxisChannelDefError: FieldDefWithoutScale<string>;\n  let continuousAxisChannelDefError2: FieldDefWithoutScale<string>;\n  let continuousAxis: 'x' | 'y';\n\n  continuousAxis = orient === 'vertical' ? 'y' : 'x';\n\n  continuousAxisChannelDef = encoding[continuousAxis] as PositionFieldDef<string>; // Safe to cast because if x is not continuous fielddef, the orient would not be horizontal.\n  continuousAxisChannelDef2 = encoding[continuousAxis + '2'] as FieldDefWithoutScale<string>;\n  continuousAxisChannelDefError = encoding[continuousAxis + 'Error'] as FieldDefWithoutScale<string>;\n  continuousAxisChannelDefError2 = encoding[continuousAxis + 'Error2'] as FieldDefWithoutScale<string>;\n\n  return {\n    continuousAxisChannelDef: filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark),\n    continuousAxisChannelDef2: filterAggregateFromChannelDef(continuousAxisChannelDef2, compositeMark),\n    continuousAxisChannelDefError: filterAggregateFromChannelDef(continuousAxisChannelDefError, compositeMark),\n    continuousAxisChannelDefError2: filterAggregateFromChannelDef(continuousAxisChannelDefError2, compositeMark),\n    continuousAxis\n  };\n}\n\nfunction filterAggregateFromChannelDef<M extends CompositeMark>(\n  continuousAxisChannelDef: FieldDef<string>,\n  compositeMark: M\n): FieldDef<string> {\n  if (isFieldDef(continuousAxisChannelDef) && continuousAxisChannelDef && continuousAxisChannelDef.aggregate) {\n    const {aggregate, ...continuousAxisWithoutAggregate} = continuousAxisChannelDef;\n    if (aggregate !== compositeMark) {\n      log.warn(log.message.errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));\n    }\n    return continuousAxisWithoutAggregate;\n  } else {\n    return continuousAxisChannelDef;\n  }\n}\n\nexport function compositeMarkOrient<M extends CompositeMark>(\n  spec: GenericUnitSpec<Encoding<Field>, CompositeMark | CompositeMarkDef>,\n  compositeMark: M\n): Orient {\n  const {mark, encoding} = spec;\n\n  if (isFieldDef(encoding.x) && isContinuous(encoding.x)) {\n    // x is continuous\n    if (isFieldDef(encoding.y) && isContinuous(encoding.y)) {\n      // both x and y are continuous\n      if (encoding.x.aggregate === undefined && encoding.y.aggregate === compositeMark) {\n        return 'vertical';\n      } else if (encoding.y.aggregate === undefined && encoding.x.aggregate === compositeMark) {\n        return 'horizontal';\n      } else if (encoding.x.aggregate === compositeMark && encoding.y.aggregate === compositeMark) {\n        throw new Error('Both x and y cannot have aggregate');\n      } else {\n        if (isMarkDef(mark) && mark.orient) {\n          return mark.orient;\n        }\n\n        // default orientation = vertical\n        return 'vertical';\n      }\n    }\n\n    // x is continuous but y is not\n    return 'horizontal';\n  } else if (isFieldDef(encoding.y) && isContinuous(encoding.y)) {\n    // y is continuous but x is not\n    return 'vertical';\n  } else {\n    // Neither x nor y is continuous.\n    throw new Error('Need a valid continuous axis for ' + compositeMark + 's');\n  }\n}\n\nexport function filterUnsupportedChannels<M extends CompositeMark, MD extends GenericCompositeMarkDef<M>>(\n  spec: GenericUnitSpec<Encoding<string>, M | MD>,\n  supportedChannels: Channel[],\n  compositeMark: M\n): GenericUnitSpec<Encoding<string>, M | MD> {\n  return {\n    ...spec,\n    encoding: reduce(\n      spec.encoding,\n      (newEncoding, fieldDef, channel) => {\n        if (supportedChannels.indexOf(channel) > -1) {\n          newEncoding[channel] = fieldDef;\n        } else {\n          log.warn(log.message.incompatibleChannel(channel, compositeMark));\n        }\n        return newEncoding;\n      },\n      {}\n    )\n  };\n}\n"]}