{"version":3,"file":"aggregate.js","sourceRoot":"","sources":["../../../../src/compile/data/aggregate.ts"],"names":[],"mappings":"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","sourcesContent":["import {AggregateOp} from 'vega';\nimport {extend} from 'vega-util';\nimport {isBinning} from '../../bin';\nimport {Channel, isScaleChannel} from '../../channel';\nimport {FieldDef, vgField} from '../../fielddef';\nimport * as log from '../../log';\nimport {AggregateTransform} from '../../transform';\nimport {Dict, duplicate, hash, isEqual, keys, replacePathInField, StringSet} from '../../util';\nimport {VgAggregateTransform} from '../../vega.schema';\nimport {binRequiresRange} from '../common';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode} from './dataflow';\n\nfunction addDimension(dims: {[field: string]: boolean}, channel: Channel, fieldDef: FieldDef<string>) {\n  if (isBinning(fieldDef.bin)) {\n    dims[vgField(fieldDef, {})] = true;\n    dims[vgField(fieldDef, {binSuffix: 'end'})] = true;\n\n    if (binRequiresRange(fieldDef, channel)) {\n      dims[vgField(fieldDef, {binSuffix: 'range'})] = true;\n    }\n  } else {\n    dims[vgField(fieldDef)] = true;\n  }\n  return dims;\n}\n\nfunction mergeMeasures(parentMeasures: Dict<Dict<StringSet>>, childMeasures: Dict<Dict<StringSet>>) {\n  for (const field in childMeasures) {\n    if (childMeasures.hasOwnProperty(field)) {\n      // when we merge a measure, we either have to add an aggregation operator or even a new field\n      const ops = childMeasures[field];\n      for (const op in ops) {\n        if (ops.hasOwnProperty(op)) {\n          if (field in parentMeasures) {\n            // add operator to existing measure field\n            parentMeasures[field][op] = {...parentMeasures[field][op], ...ops[op]};\n          } else {\n            parentMeasures[field] = {[op]: ops[op]};\n          }\n        }\n      }\n    }\n  }\n}\n\nexport class AggregateNode extends DataFlowNode {\n  public clone() {\n    return new AggregateNode(null, {...this.dimensions}, duplicate(this.measures));\n  }\n\n  /**\n   * @param dimensions string set for dimensions\n   * @param measures dictionary mapping field name => dict of aggregation functions and names to use\n   */\n  constructor(\n    parent: DataFlowNode,\n    private dimensions: StringSet,\n    private measures: Dict<{[key in AggregateOp]?: StringSet}>\n  ) {\n    super(parent);\n  }\n\n  get groupBy(): StringSet {\n    return this.dimensions;\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: UnitModel): AggregateNode {\n    let isAggregate = false;\n    model.forEachFieldDef(fd => {\n      if (fd.aggregate) {\n        isAggregate = true;\n      }\n    });\n\n    const meas = {};\n    const dims = {};\n\n    if (!isAggregate) {\n      // no need to create this node if the model has no aggregation\n      return null;\n    }\n\n    model.forEachFieldDef((fieldDef, channel) => {\n      const {aggregate, field} = fieldDef;\n      if (aggregate) {\n        if (aggregate === 'count') {\n          meas['*'] = meas['*'] || {};\n          meas['*']['count'] = {[vgField(fieldDef, {forAs: true})]: true};\n        } else {\n          meas[field] = meas[field] || {};\n          meas[field][aggregate] = {[vgField(fieldDef, {forAs: true})]: true};\n\n          // For scale channel with domain === 'unaggregated', add min/max so we can use their union as unaggregated domain\n          if (isScaleChannel(channel) && model.scaleDomain(channel) === 'unaggregated') {\n            meas[field]['min'] = {[vgField({field, aggregate: 'min'}, {forAs: true})]: true};\n            meas[field]['max'] = {[vgField({field, aggregate: 'max'}, {forAs: true})]: true};\n          }\n        }\n      } else {\n        addDimension(dims, channel, fieldDef);\n      }\n    });\n\n    if (keys(dims).length + keys(meas).length === 0) {\n      return null;\n    }\n\n    return new AggregateNode(parent, dims, meas);\n  }\n\n  public static makeFromTransform(parent: DataFlowNode, t: AggregateTransform): AggregateNode {\n    const dims = {};\n    const meas = {};\n\n    for (const s of t.aggregate) {\n      const {op, field, as} = s;\n      if (op) {\n        if (op === 'count') {\n          meas['*'] = meas['*'] || {};\n          meas['*']['count'] = {[as]: true} || {[vgField(s, {forAs: true})]: true};\n        } else {\n          meas[field] = meas[field] || {};\n          meas[field][op] = {[as]: true} || {[vgField(s, {forAs: true})]: true};\n        }\n      }\n    }\n\n    for (const s of t.groupby || []) {\n      dims[s] = true;\n    }\n\n    if (keys(dims).length + keys(meas).length === 0) {\n      return null;\n    }\n\n    return new AggregateNode(parent, dims, meas);\n  }\n\n  public merge(other: AggregateNode): boolean {\n    if (isEqual(this.dimensions, other.dimensions)) {\n      mergeMeasures(this.measures, other.measures);\n      return true;\n    } else {\n      log.debug('different dimensions, cannot merge');\n      return false;\n    }\n  }\n\n  public addDimensions(fields: string[]) {\n    fields.forEach(f => (this.dimensions[f] = true));\n  }\n\n  public dependentFields() {\n    const out = {};\n\n    keys(this.dimensions).forEach(f => (out[f] = true));\n    keys(this.measures).forEach(m => (out[m] = true));\n\n    return out;\n  }\n\n  public producedFields() {\n    const out = {};\n\n    for (const field of keys(this.measures)) {\n      for (const op of keys(this.measures[field])) {\n        if (keys(this.measures[field][op]).length === 0) {\n          out[`${op}_${field}`] = true;\n        } else {\n          extend(out, this.measures[field][op]);\n        }\n      }\n    }\n\n    return out;\n  }\n\n  public hash() {\n    return `Aggregate ${hash({dimensions: this.dimensions, measures: this.measures})}`;\n  }\n\n  public assemble(): VgAggregateTransform {\n    const ops: AggregateOp[] = [];\n    const fields: string[] = [];\n    const as: string[] = [];\n\n    for (const field of keys(this.measures)) {\n      for (const op of keys(this.measures[field])) {\n        for (const alias of keys(this.measures[field][op])) {\n          as.push(alias);\n          ops.push(op);\n          fields.push(replacePathInField(field));\n        }\n      }\n    }\n\n    const result: VgAggregateTransform = {\n      type: 'aggregate',\n      groupby: keys(this.dimensions),\n      ops,\n      fields,\n      as\n    };\n\n    return result;\n  }\n}\n"]}